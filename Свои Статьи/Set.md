# SET and FROZENSET   

**Set (множества)** - это непорядочная коллекция уникальных элементов. Относится  к разряду итерируемых объектов, поддерживает оператор проверки на вхождение `in `  и `not in`, функцию `len()`.  

**Set** – это неупорядоченная коллекция из нуля или более ссылок на объекты, указывающих на хешируемые объекты.  

Кроме того:

- множества предоставляют метод `set.isdisjoint()`  

  ```python
  sets.isdisjoint(iterable) -> bool
    myset = {1, 2, 'some'}
      myset.isdisjoint(['2', 4, 6])  # True
      myset.isdisjoint([2, 4, 6])  # False
  """
  Возвращает True, если в рассматриваемом множестве не найдено элементов, присутствующих в указанном объекте.
  Множества не пересекаются тогда и только тогда, когда их пересечение пусто.
  """
  ```

* поддерживают операторы сравнения (<, <=, ==, !=, >=, >)    
* поддерживают битовые операторы (которые в контексте множеств используются для получения объединения, пересечения и т. д. см. ниже)  
* множества относятся к категории изменяемых типов, поэтому легко можно добавлять и удалять их элементы
* не применимо понятие индекса и не применима операция извлечения среза.     
* в состав множеств могут включаться только хешируемые объекты.  

**Хешируемые объекты** – это объекты, имеющие специальный метод `__hash__()`, на протяжении всего жизненного цикла объекта всегда возвращающий одно и то же значение, которые могут участвовать в операциях сравнения на равенство посредством специального метода `__eq__()`.  Все встроенные неизменяемые типы данных, такие как float, frozenset, int, str и tuple, являются хешируемыми объектами и могут добавляться во множества. Встроенные изменяемые типы данных, такие как dict, list и set, не являются хешируемыми объектами  

Имеется *два встроенных типа множеств*: **изменяемый тип set** и **неизменяемый frozenset**.  

#### Тип данных Set может вызываться:

1. как функция set()   – без аргументов  она возвращает пустое множество

   ```python
   my_set = set()
   ```

2. с аргументом типа set возвращает поверхностную копию аргумента. В случае, если аргумент имеет другой тип, выполняется попытка преобразовать его в объект типа set  

   ```python
   num_set = set([1, 2, 3, 4, 5, 6])  
   print(num_set) # {1, 2, 3, 4, 5, 6}
   ```

3.  непустые множества могут создаваться без использования функции set(), а пустые множества могут создаваться только с помощью функции set() – их нельзя создать с помощью пары пустых скобок.  

Операторы множества см. рисунок

#### ![операторы множества](.\picture\операторы множества.png)Методы и операторы множеств

| Метод                                         | Описание                                                     | fSet |
| --------------------------------------------- | ------------------------------------------------------------ | ---- |
| s.add(x)                                      | Добавляет элементы x во множество s, если они отсутствуют в s |      |
| s.clear()                                     | Удаляет все элементы из множества s                          |      |
| s.copy()                                      | Возвращает поверхностную копию множества s                   | FS   |
| s.difference(t)<br />s - t                    | Возвращает новое множество, включающее элементы множества s, которые отсутствуют в множестве t | FS   |
| s.difference_update(t) s -= t                 | Удаляет из множества s все элементы, присутствующие в множестве t |      |
| s.discard(x)                                  | Удаляет элемент x из множества s, если он присутствует в множестве s. В отличие от remove() не выдает ошибку, если элемента нет. |      |
| s.intersection(t)<br />s & t                  | Возвращает новое множество, включающее элементы, присутствующие одновременно в множествах s и t | FS   |
| s.intersection_update(t)<br />s &= t          | Оставляет во множестве s пересечение множеств s и t          |      |
| s.isdisjoint(t)                               | Возвращает True, если множества s и t не имеют общих элементов | FS   |
| s.issubset(t)<br />s <= t                     | Возвращает True, если множество s эквивалентно множеству t или является его подмножеством; чтобы проверить, является ли множество s только подмножеством множества t, следует использовать проверку s < t | FS   |
| s.issuperset(t) <br />s >= t                  | Возвращает True, если множество s эквивалентно множеству t или является его надмножеством; чтобы проверить, является ли множество s только надмножеством множества t, следует использовать проверку s > t |      |
| s.pop()                                       | Возвращает и удаляет случайный элемент множества s или возбуждает исключение KeyError, если s – это пустое множество |      |
| s.remove(x)                                   | Удаляет элемент x из множества s или возбуждает исключение KeyError, если элемент x отсутствует в множестве s |      |
| s.symmetric_ difference(t)<br />s ^ t         | Возвращает новое множество, включающее все элементы, присутствующие в множествах s и t, за исключением элементов, присутствующих в обоих множествах одновременно | FS   |
| s.symmetric_ difference_update(t)<br />s ^= t | Возвращает в множестве s результат строгой дизъюнкции множеств s и t | FS   |
| s.union(t) <br /> s \|t                       | Возвращает новое множество, включающее все элементы множества s и все элементы множества t, отсутствующие в множестве s | FS   |
| s.update(t) <br />s \|= t                     | Добавляет во множество s все элементы множества t, отсутствующие в множестве s |      |
|                                               |                                                              |      |

Если двухместный оператор применяется ко множеству и фиксированному множеству, тип результата будет совпадать с типом операнда,
стоящего слева от оператора.  То есть если предположить, что f – это фиксированное множество, а s – это обычное множество, то выражение f & s вернет объект типа frozenset, а выражение s & f – объект типа Set

#### Когда удобно использовать множества:

1. когда необходимо организовать быструю проверку на вхождение  

2. когда необходимо избежать обработки повторяющихся элементов данных  

3. могут использоваться для удаления требуемых элементов  

   ```python
   filenames = set(filenames)
   for makefile in {"MAKEFILE", "Makefile", "makefile"}:
   filenames.discard(makefile)
   ```

#### Генератор множеств:

**Генератор множества** – это выражение и цикл с необязательным условием, заключенные в фигурные скобки.  

```python
{expression for item in iterable}
{expression for item in iterable if condition}
#Пример
html = {x for x in files if x.lower().endswith((".htm", ".html"))}
```

## <u>Тип frozenset</u>  

**Фиксированное множество (frozenset)** – это множество, которое после создания невозможно изменить.

#### Тип данных frozenset может создаваться:

1. как функция frozenset ()   – без аргументов возвращается пустое фиксированное множество  

2. с аргументом типа frozenset  возвращает поверхностную копию аргумента. В случае, если аргумент имеет другой тип, выполняется попытка преобразовать его в объект типа frozenset    

   ```python
   frozenset([iterable])
   my_set = frozenset()
   my_set  # frozenset()
   
   my_set = frozenset([1, 2, 3, -10, 40])
   my_set  # frozenset({-10, 1, 2, 3, 40})
   ```

