# SET and FROZENSET   

**Set (множества)** - это непорядочная коллекция уникальных элементов. Относится к относится к разряду итерируемых объектов, поддерживает оператор проверки на вхождение `in `  и `not in`, функцию `len()`.  

**Set** – это неупорядоченная коллекция из нуля или более ссылок на объекты, указывающих на хешируемые объекты.  

Кроме того:

- множества предоставляют метод `set.isdisjoint()`  

  ```python
  sets.isdisjoint(iterable) -> bool
    myset = {1, 2, 'some'}
      myset.isdisjoint(['2', 4, 6])  # True
      myset.isdisjoint([2, 4, 6])  # False
  """
  Возвращает True, если в рассматриваемом множестве не найдено элементов, присутствующих в указанном объекте.
  Множества не пересекаются тогда и только тогда, когда их пересечение пусто.
  """
  ```

* поддерживают операторы сравнения (<, <=, ==, !=, >=, >)    
* поддерживают битовые операторы (которые в контексте множеств используются для получения объединения, пересечения и т. д. см. ниже)  
* множества относятся к категории изменяемых типов, поэтому легко можно добавлять и удалять их элементы
* не применимо понятие индекса и не применима операция извлечения среза.     
* в состав множеств могут включаться только хешируемые объекты.  

**Хешируемые объекты** – это объекты, имеющие специальный метод `__hash__()`, на протяжении всего жизненного цикла объекта всегда возвращающий одно и то же значение, которые могут участвовать в операциях сравнения на равенство посредством специального метода `__eq__()`.  Все встроенные неизменяемые типы данных, такие как float, frozenset, int, str и tuple, являются хешируемыми объектами и могут добавляться во множества. Встроенные изменяемые типы данных, такие как dict, list и set, не являются хешируемыми объектами  

Имеется *два встроенных типа множеств*: **изменяемый тип set** и **неизменяемый frozenset**.  

#### Тип данных Set может вызываться:

1. как функция set()   – без аргументов  она возвращает пустое множество

   ```python
   my_set = set()
   ```

2. с аргументом типа set возвращает поверхностную копию аргумента. В случае, если аргумент имеет другой тип, выполняется попытка преобразовать его в объект типа set  

   ```python
   num_set = set([1, 2, 3, 4, 5, 6])  
   print(num_set) # {1, 2, 3, 4, 5, 6}
   ```

3.  непустые множества могут создаваться без использования функции set(), а пустые множества могут создаваться только с помощью функции set() – их нельзя создать с помощью пары пустых скобок.  

Операторы множества см. рисунок

![операторы множества](E:\УЧЕБА_git\Lubeshko_Python\Свои Статьи\picture\операторы множества.png)

Вставить таблицу методоЮБЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮ

#### Когда удобно использовать множества:

1. когда необходимо организовать быструю проверку на вхождение  

2. когда необходимо избежать обработки повторяющихся элементов данных  

3. могут использоваться для удаления требуемых элементов  

   ```python
   filenames = set(filenames)
   for makefile in {"MAKEFILE", "Makefile", "makefile"}:
   filenames.discard(makefile)
   ```

#### Когда удобно использовать множества:

**Генератор множества** – это выражение и цикл с необязательным условием, заключенные в фигурные скобки.  

```python
{expression for item in iterable}
{expression for item in iterable if condition}
#Пример
html = {x for x in files if x.lower().endswith((".htm", ".html"))}
```

## <u>Тип frozenset</u>  

**Фиксированное множество (frozenset)** – это множество, которое после создания невозможно изменить.

#### Тип данных frozenset может создаваться:

1. как функция frozenset ()   – без аргументов возвращается пустое фиксированное множество  

2. с аргументом типа frozenset  возвращает поверхностную копию аргумента. В случае, если аргумент имеет другой тип, выполняется попытка преобразовать его в объект типа frozenset    

   ```python
   frozenset([iterable])
   my_set = frozenset()
   my_set  # frozenset()
   
   my_set = frozenset([1, 2, 3, -10, 40])
   my_set  # frozenset({-10, 1, 2, 3, 40})
   ```

Вставить МЕТОДЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ + с 150

Если предположить, что f – это фиксированное множество, а s – это обычное множество, то выражение f & s вернет объект типа frozenset, а выражение s & f – объект тиПоверхно стное и глубокое копирование,

стр. 173
Отображения 151
па set. В случае операторов == и != порядок операндов не имеет значе
ния, и выражение f == s вернет True, только если оба множества содер
жат одни и те же элементы.