# СТРОКИ

``` неизменяемыый тип данных```      ``  хранят последовательность символов Юникод ``

> Вызывается `str()`:
>
> * Как функция без аргумента  вернет  пустую строку
>
> * Как функция c аргументом, который не является строкой
>
> * Как функция c аргументом, который  является строкой, возвращается его копия
>
> * Функция str() может также использоваться как функция преобразования.  Тогда первый аргумент должен быть строкой или объектом, кроме того в функцию можно передать до 2 аргументов (кодировка и порядок обработки ошибок):
>
>  ```python
>  Пример
>     s = str(a, encoding = "ascii", errors ="ignore")
>  ```
>
###### Немного про литералы, экранирование, перевод строк
>>1. Литералы строк создаются с использованием кавычек или апострофов. Важно, чтобы с обоих концов литерала использовались кавычки одного и того же типа. Можем использовать строки в *тройных кавычках*
>
>>```
>>Пример литералов с экранированием
>>a = "Здесь 'апострофы' можно не экранировать, а \"кавычки\" придется."
>>```
>
>>2. Символ перевода строки  `\n  ` интерпретируется как завершающий символ инструкции, но не внутри круглых скобок (()), квадратных скобок ([]), фигурных скобок ({}) и **строк в тройных кавычках**
>>
>>3. [Основные экранированные последовательности, допустимые в языке Python](https://pyprog.pro/python/py/str/esqape_sec.html)  
>>
>>4. Способ записи длинного строкового литерала:
>>
>>   ```python
>>   t = "Это не самый лучший способ объединения двух длинных строк, " + \
>>   "потому что он основан на использовании неуклюжего экранирования"
>>   s = ("Это отличный способ объединить две длинные строки, "
>>   " потому что он основан на конкатенации строковых литералов.")
>>   ```

> > 5. Для определения кода символа Юникода можно использовать встроенную функцию `ord()`.  Преобразовать допустимое целое число  можно использовать функцию `chr()`.

### Сравнение строк ##  

Строки поддерживают обычные операторы сравнения `<, <=, ==, !=, > и >= ` . Операторы выполняют побайтовое сравнение строк в памяти.  

Существуют 2 проблемы при сравнении строк:

1. Символы Юникода могут быть представлены двумя и более последовательностями байтов. Например, A° (символ Юникода с кодом0x00C5) в кодировке UTF-8 может быть представлен тремя
   различными способами: [0xE2, 0x84, 0xAB], [0xC3, 0x85]и [0x41, 0xCC, 0x8A].  Решить эту
   проблему. Если импортировать модуль unicodedata и вызвать функцию unicodedata.normalize() со значением «NFKD»  

   ```
   s= unicodedata.normalize('NFKD', "Å").encode('utf-8')
   b'x41\xcc\x8a'
   
   ```

2. Вторая проблема заключается в том, что порядок сортировки некоторых символов зависит от конкретного языка.   

### Срез строк ###

```python
Оператор получения среза имеет три формы записи:
seq[start] - 'элемент'
seq[start:end] - ' подстрока, индекс end не вкдючается'
seq[start:end:step] - 'подстрока с шагом извлечения'
```

Значения start, end и step должны быть целыми числами (или переменными, хранящими целые числа).  

- Ссылка  `seq  ` любую последовательность, такую как список, строку или кортеж.
- Один из способов вставить подстроку в строку  `s[:12] + "wo" + s[12:] ` . Однако, оператор конкатенации + и добавления подстроки += не особенно эффективны  Для объединения большого числа строк обычно лучше использовать метод `str.join() ` 

### Операторы и методы строк  ### 

* Оператор проверки на вхождение `in`
* Оператор конкатенации `+ ` 
* Оператор добавления в конец `+= ` 
* Оператор дублирования `*` 
* Присваивания с дублированием `*=`  

